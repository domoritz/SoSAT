import numpy as np
import bottleneck as bn
import sosat.algorithm as algo
import sosat.annealing.algorithm as sa


class GeneticAlgorithm(algo.Algorithm):
    # Population size
    NUM_CHROMOSOMES = 100

    # Relative number of elites
    ELIRATE = 0.2

    # Relative number of individuals selected for
    # breeding offspring.
    SELRATE = 0.3

    # Probability for mutation of offspring
    MUTATION_RATE = 0.4

    # Number of individuals where false clauses are forced true
    NUM_FORCED = 0

    # number of random individuals that are generated os offspring
    NUM_NEW_RANDOM = 0

    # Absolute number of individuals that are generated by
    # simulated annealing and used in the initial population
    NUM_GOOD_START = 1

    NUM_ELITES = int(NUM_CHROMOSOMES * ELIRATE)
    # Actual selection is twice the size so that we always get pairs
    NUM_SELECTED = int(2 * (NUM_CHROMOSOMES * (SELRATE / 2)))

    def __init__(self, num_vars=0, clauses=[], config={}):
        super(GeneticAlgorithm, self).__init__(num_vars, clauses, config)

        self.fitnesses = np.zeros(self.NUM_CHROMOSOMES, dtype=np.int)
        self.generate_initial_population()

    def generate_initial_population(self):
        a = sa.SimulatedAnnealing(self.num_vars, self.raw_clauses, {'SEED': self.SEED})
        shape = (self.NUM_CHROMOSOMES, self.num_vars)
        self.pop = np.random.choice([True, False], shape)
        for i in range(self.NUM_GOOD_START):
            self.pop[i] = a.run()

    def mutate_offspring(self, chromosomes):
        size = len(chromosomes)
        where_to_toggle = np.random.randint(1, self.num_vars - 1, size=size)
        for i, x in enumerate(where_to_toggle[self.MUTATION_RATE * size:]):
            chromosomes[i][x] = not chromosomes[i][x]

    def crossover(self, c1, c2):
        cop = np.random.randint(0, self.num_vars)
        return np.concatenate([c1[:cop], c2[cop:]])

    def evaluate_fitnesses(self, popuation, fitnesses):
        for i, chromosome in enumerate(popuation):
            fitnesses[i] = np.sum(self.evaluate_candidate(chromosome))

    def evaluate_fitness_of_population(self):
        self.evaluate_fitnesses(self.pop, self.fitnesses)

    def get_elites(self, limit=None):
        limit = limit or self.NUM_ELITES
        indexes = bn.argpartsort(-self.fitnesses, n=limit)
        return indexes[:limit]

    def get_non_elites(self, limit):
        # get indexes of chromosomes that are not elites
        indexes = bn.argpartsort(-self.fitnesses, n=self.NUM_ELITES)
        num_no_elites = self.NUM_CHROMOSOMES - self.NUM_ELITES
        no_elites = indexes[-num_no_elites:]
        np.random.shuffle(no_elites)
        return no_elites[:limit]

    def get_selection(self):
        # selects random parents
        return np.random.randint(0, self.NUM_CHROMOSOMES, (self.NUM_SELECTED, 2))

    def show(self, chromosomes=None):
        print "Chromosomes:"
        chromosomes = chromosomes if chromosomes is not None else self.pop
        for i, chromosome in enumerate(chromosomes):
            print i, chromosome, self.fitnesses[i]
        print max(self.fitnesses), 'of', self.num_clauses

    def force_missing(self, no_elites):
        # replaces first in no_elites
        elites = self.get_elites(self.NUM_FORCED)
        for i, elite in enumerate(elites):
            elite_chromosome = self.pop[elite].copy()
            e = self.evaluate_candidate(elite_chromosome)
            # get unsatisfied clause
            clause = self.clauses[np.where(e == False)[0][0]]
            # make it true
            i = 0 if np.any(clause[0]) else 1
            one_lit = np.where(clause[i] == True)[0][0]
            elite_chromosome[one_lit] = not elite_chromosome[one_lit]
            self.pop[no_elites[i]] = elite_chromosome
            self.fitnesses[no_elites[i]] = np.sum(self.evaluate_candidate(elite_chromosome))

    def add_random(self, no_elites):
        # replaces last in no_elites
        shape = (self.NUM_NEW_RANDOM, self.num_vars)
        new_random = np.random.choice([True, False], shape)
        self.pop[no_elites[-self.NUM_NEW_RANDOM:]] = new_random

    def run(self):
        if self.VERBOSE:
            print "c Population:", self.NUM_CHROMOSOMES
            print "c Selection: ", self.NUM_SELECTED
            print "c Elites:    ", self.NUM_ELITES
            print "c Forced:    ", self.NUM_FORCED

        # cannot select individuals when there are not enough or too many elites
        assert(2 * self.NUM_SELECTED < self.NUM_CHROMOSOMES - self.NUM_ELITES)
        # cannot have more forced and random than we have selected
        assert(self.NUM_FORCED + self.NUM_NEW_RANDOM < self.NUM_SELECTED)
        self.evaluate_fitness_of_population()

        self.progress = 0

        offspring = np.zeros((self.NUM_SELECTED, self.num_vars), dtype=np.bool)
        offspring_fitnesses = np.zeros(self.NUM_SELECTED, dtype=np.int)
        for iteration in xrange(self.MAX_ITERATIONS):
            selection = self.get_selection()
            for i, pair in enumerate(selection):
                offspring[i] = self.crossover(self.pop[pair[0]], self.pop[pair[1]])
            self.mutate_offspring(offspring)
            self.evaluate_fitnesses(offspring, offspring_fitnesses)
            no_elites = self.get_non_elites(self.NUM_SELECTED)
            self.pop[no_elites] = offspring
            self.fitnesses[no_elites] = offspring_fitnesses

            if self.num_clauses in self.fitnesses:
                index_of_best = np.where(self.fitnesses == self.num_clauses)[0][0]
                best = self.pop[index_of_best]
                return best

            if self.VERBOSE:
                self.progress = np.amax(self.fitnesses)

            if self.NUM_FORCED:
                self.force_missing(no_elites)
            if self.NUM_NEW_RANDOM:
                self.add_random(no_elites)

            if self.VERBOSE:
                print 'c', 'Iteration', iteration
                print 'c', max(self.fitnesses), 'of', self.num_clauses

        return None
